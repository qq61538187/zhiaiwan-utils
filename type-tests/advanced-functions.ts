import {
	add,
	after,
	ary,
	assign,
	assignIn,
	assignInWith,
	assignWith,
	at,
	before,
	bind,
	bindKey,
	camelCase,
	capitalize,
	castArray,
	ceil,
	chain,
	chunk,
	clamp,
	clone,
	cloneDeep,
	cloneDeepWith,
	cloneWith,
	compact,
	concat,
	conformsTo,
	countBy,
	create,
	curry,
	curryRight,
	debounce,
	deburr,
	defaults,
	defaultsDeep,
	defer,
	delay,
	difference,
	differenceBy,
	differenceWith,
	divide,
	drop,
	dropRight,
	dropRightWhile,
	dropWhile,
	each,
	eachRight,
	endsWith,
	entries,
	entriesIn,
	eq,
	escapeRegExp,
	escape as escapeUtil,
	every,
	extend,
	extendWith,
	fill,
	filter,
	find,
	findIndex,
	findKey,
	findLast,
	findLastIndex,
	findLastKey,
	first,
	flatMap,
	flatMapDeep,
	flatMapDepth,
	flatten,
	flattenDeep,
	flattenDepth,
	flip,
	floor,
	forEach,
	forEachRight,
	forIn,
	forInRight,
	forOwn,
	forOwnRight,
	fromPairs,
	functions,
	functionsIn,
	get,
	groupBy,
	gt,
	gte,
	has,
	hasIn,
	head,
	includes,
	indexOf,
	initial,
	inRange,
	intersection,
	intersectionBy,
	intersectionWith,
	invert,
	invertBy,
	invoke,
	invokeMap,
	isArguments,
	isArray,
	isArrayBuffer,
	isArrayLike,
	isArrayLikeObject,
	isBoolean,
	isBuffer,
	isDate,
	isElement,
	isEmpty,
	isEqual,
	isEqualWith,
	isError,
	isFinite as isFiniteUtil,
	isFunction,
	isInteger,
	isLength,
	isMap,
	isMatch,
	isMatchWith,
	isNaN as isNaNUtil,
	isNative,
	isNil,
	isNull,
	isNumber,
	isObject,
	isObjectLike,
	isPlainObject,
	isRegExp,
	isSafeInteger,
	isSet,
	isString,
	isSymbol,
	isTypedArray,
	isUndefined,
	isWeakMap,
	isWeakSet,
	join,
	kebabCase,
	keyBy,
	keys,
	keysIn,
	last,
	lastIndexOf,
	lowerCase,
	lowerFirst,
	lt,
	lte,
	map,
	mapKeys,
	mapValues,
	max,
	maxBy,
	mean,
	meanBy,
	memoize,
	merge,
	mergeWith,
	methods,
	methodsIn,
	min,
	minBy,
	multiply,
	negate,
	now,
	nth,
	omit,
	omitBy,
	once,
	orderBy,
	overArgs,
	pad,
	padEnd,
	padStart,
	partial,
	partialRight,
	partition,
	pick,
	pickBy,
	pull,
	pullAll,
	pullAllBy,
	pullAllWith,
	pullAt,
	random,
	rearg,
	reduce,
	reduceRight,
	reject,
	remove,
	repeat,
	replace,
	rest,
	result,
	reverse,
	round,
	sample,
	sampleSize,
	set,
	setWith,
	shuffle,
	size,
	slice,
	snakeCase,
	some,
	sortBy,
	sortedIndex,
	sortedIndexBy,
	sortedIndexOf,
	sortedLastIndex,
	sortedLastIndexBy,
	sortedLastIndexOf,
	sortedUniq,
	sortedUniqBy,
	split,
	spread,
	startCase,
	startsWith,
	subtract,
	sum,
	sumBy,
	tail,
	take,
	takeRight,
	takeRightWhile,
	takeWhile,
	tap,
	template,
	throttle,
	thru,
	toArray,
	toFinite,
	toInteger,
	toLength,
	toLower,
	toNumber,
	toPairs,
	toPairsIn,
	toPlainObject,
	toSafeInteger,
	toString as toStringUtil,
	toUpper,
	transform,
	trim,
	trimEnd,
	trimStart,
	truncate,
	unary,
	unescape as unescapeUtil,
	union,
	unionBy,
	unionWith,
	uniq,
	uniqBy,
	uniqWith,
	unset,
	unzip,
	unzipWith,
	update,
	updateWith,
	upperCase,
	upperFirst,
	values,
	valuesIn,
	without,
	words,
	wrap,
	xor,
	xorBy,
	xorWith,
	zip,
	zipObject,
	zipObjectDeep,
	zipWith,
} from "@zhiaiwan/utils";

const methodMethodNames = [
	"chunk",
	"compact",
	"concat",
	"difference",
	"differenceBy",
	"differenceWith",
	"drop",
	"dropRight",
	"dropRightWhile",
	"dropWhile",
	"fill",
	"findIndex",
	"findLastIndex",
	"flatten",
	"flattenDeep",
	"flattenDepth",
	"fromPairs",
	"head",
	"indexOf",
	"initial",
	"intersection",
	"intersectionBy",
	"intersectionWith",
	"join",
	"last",
	"lastIndexOf",
	"nth",
	"pull",
	"pullAll",
	"pullAllBy",
	"pullAllWith",
	"pullAt",
	"remove",
	"reverse",
	"slice",
	"sortedIndex",
	"sortedIndexBy",
	"sortedIndexOf",
	"sortedLastIndex",
	"sortedLastIndexBy",
	"sortedLastIndexOf",
	"sortedUniq",
	"sortedUniqBy",
	"tail",
	"take",
	"takeRight",
	"takeRightWhile",
	"takeWhile",
	"union",
	"unionBy",
	"unionWith",
	"uniq",
	"uniqBy",
	"uniqWith",
	"unzip",
	"unzipWith",
	"without",
	"xor",
	"xorBy",
	"xorWith",
	"zip",
	"zipObject",
	"zipObjectDeep",
	"zipWith",
	"first",
	"countBy",
	"every",
	"filter",
	"find",
	"findLast",
	"flatMap",
	"flatMapDeep",
	"flatMapDepth",
	"forEach",
	"forEachRight",
	"groupBy",
	"includes",
	"invokeMap",
	"keyBy",
	"map",
	"orderBy",
	"partition",
	"reduce",
	"reduceRight",
	"reject",
	"sample",
	"sampleSize",
	"shuffle",
	"size",
	"some",
	"sortBy",
	"each",
	"eachRight",
	"now",
	"after",
	"ary",
	"before",
	"bind",
	"bindKey",
	"curry",
	"curryRight",
	"debounce",
	"defer",
	"delay",
	"flip",
	"memoize",
	"negate",
	"once",
	"overArgs",
	"partial",
	"partialRight",
	"rearg",
	"rest",
	"spread",
	"throttle",
	"unary",
	"wrap",
	"castArray",
	"clone",
	"cloneDeep",
	"cloneDeepWith",
	"cloneWith",
	"conformsTo",
	"eq",
	"gt",
	"gte",
	"isArguments",
	"isArray",
	"isArrayBuffer",
	"isArrayLike",
	"isArrayLikeObject",
	"isBoolean",
	"isBuffer",
	"isDate",
	"isElement",
	"isEmpty",
	"isEqual",
	"isEqualWith",
	"isError",
	"isFinite",
	"isFunction",
	"isInteger",
	"isLength",
	"isMap",
	"isMatch",
	"isMatchWith",
	"isNaN",
	"isNative",
	"isNil",
	"isNull",
	"isNumber",
	"isObject",
	"isObjectLike",
	"isPlainObject",
	"isRegExp",
	"isSafeInteger",
	"isSet",
	"isString",
	"isSymbol",
	"isTypedArray",
	"isUndefined",
	"isWeakMap",
	"isWeakSet",
	"lt",
	"lte",
	"toArray",
	"toFinite",
	"toInteger",
	"toLength",
	"toNumber",
	"toPlainObject",
	"toSafeInteger",
	"toString",
	"add",
	"ceil",
	"divide",
	"floor",
	"max",
	"maxBy",
	"mean",
	"meanBy",
	"min",
	"minBy",
	"multiply",
	"round",
	"subtract",
	"sum",
	"sumBy",
	"clamp",
	"inRange",
	"random",
	"assign",
	"assignIn",
	"assignInWith",
	"assignWith",
	"at",
	"create",
	"defaults",
	"defaultsDeep",
	"entries",
	"entriesIn",
	"extend",
	"extendWith",
	"findKey",
	"findLastKey",
	"forIn",
	"forInRight",
	"forOwn",
	"forOwnRight",
	"functions",
	"functionsIn",
	"get",
	"has",
	"hasIn",
	"invert",
	"invertBy",
	"invoke",
	"keys",
	"keysIn",
	"mapKeys",
	"mapValues",
	"merge",
	"mergeWith",
	"omit",
	"omitBy",
	"pick",
	"pickBy",
	"result",
	"set",
	"setWith",
	"toPairs",
	"toPairsIn",
	"transform",
	"unset",
	"update",
	"updateWith",
	"values",
	"valuesIn",
	"methods",
	"methodsIn",
	"chain",
	"tap",
	"thru",
	"camelCase",
	"capitalize",
	"deburr",
	"endsWith",
	"escape",
	"escapeRegExp",
	"kebabCase",
	"lowerCase",
	"lowerFirst",
	"pad",
	"padEnd",
	"padStart",
	"parseInt",
	"repeat",
	"replace",
	"snakeCase",
	"split",
	"startCase",
	"startsWith",
	"template",
	"toLower",
	"toUpper",
	"trim",
	"trimEnd",
	"trimStart",
	"truncate",
	"unescape",
	"upperCase",
	"upperFirst",
	"words",
] as const;

type MethodMethodName = (typeof methodMethodNames)[number];

const parityTypeCoverage: Record<MethodMethodName, unknown> = {
	chunk,
	compact,
	concat,
	difference,
	differenceBy,
	differenceWith,
	drop,
	dropRight,
	dropRightWhile,
	dropWhile,
	fill,
	findIndex,
	findLastIndex,
	flatten,
	flattenDeep,
	flattenDepth,
	fromPairs,
	head,
	indexOf,
	initial,
	intersection,
	intersectionBy,
	intersectionWith,
	join,
	last,
	lastIndexOf,
	nth,
	pull,
	pullAll,
	pullAllBy,
	pullAllWith,
	pullAt,
	remove,
	reverse,
	slice,
	sortedIndex,
	sortedIndexBy,
	sortedIndexOf,
	sortedLastIndex,
	sortedLastIndexBy,
	sortedLastIndexOf,
	sortedUniq,
	sortedUniqBy,
	tail,
	take,
	takeRight,
	takeRightWhile,
	takeWhile,
	union,
	unionBy,
	unionWith,
	uniq,
	uniqBy,
	uniqWith,
	unzip,
	unzipWith,
	without,
	xor,
	xorBy,
	xorWith,
	zip,
	zipObject,
	zipObjectDeep,
	zipWith,
	first,
	countBy,
	every,
	filter,
	find,
	findLast,
	flatMap,
	flatMapDeep,
	flatMapDepth,
	forEach,
	forEachRight,
	groupBy,
	includes,
	invokeMap,
	keyBy,
	map,
	orderBy,
	partition,
	reduce,
	reduceRight,
	reject,
	sample,
	sampleSize,
	shuffle,
	size,
	some,
	sortBy,
	each,
	eachRight,
	now,
	after,
	ary,
	before,
	bind,
	bindKey,
	curry,
	curryRight,
	debounce,
	defer,
	delay,
	flip,
	memoize,
	negate,
	once,
	overArgs,
	partial,
	partialRight,
	rearg,
	rest,
	spread,
	throttle,
	unary,
	wrap,
	castArray,
	clone,
	cloneDeep,
	cloneDeepWith,
	cloneWith,
	conformsTo,
	eq,
	gt,
	gte,
	isArguments,
	isArray,
	isArrayBuffer,
	isArrayLike,
	isArrayLikeObject,
	isBoolean,
	isBuffer,
	isDate,
	isElement,
	isEmpty,
	isEqual,
	isEqualWith,
	isError,
	isFinite: isFiniteUtil,
	isFunction,
	isInteger,
	isLength,
	isMap,
	isMatch,
	isMatchWith,
	isNaN: isNaNUtil,
	isNative,
	isNil,
	isNull,
	isNumber,
	isObject,
	isObjectLike,
	isPlainObject,
	isRegExp,
	isSafeInteger,
	isSet,
	isString,
	isSymbol,
	isTypedArray,
	isUndefined,
	isWeakMap,
	isWeakSet,
	lt,
	lte,
	toArray,
	toFinite,
	toInteger,
	toLength,
	toNumber,
	toPlainObject,
	toSafeInteger,
	toString: Object.prototype.toString,
	add,
	ceil,
	divide,
	floor,
	max,
	maxBy,
	mean,
	meanBy,
	min,
	minBy,
	multiply,
	round,
	subtract,
	sum,
	sumBy,
	clamp,
	inRange,
	random,
	assign,
	assignIn,
	assignInWith,
	assignWith,
	at,
	create,
	defaults,
	defaultsDeep,
	entries,
	entriesIn,
	extend,
	extendWith,
	findKey,
	findLastKey,
	forIn,
	forInRight,
	forOwn,
	forOwnRight,
	functions,
	functionsIn,
	get,
	has,
	hasIn,
	invert,
	invertBy,
	invoke,
	keys,
	keysIn,
	mapKeys,
	mapValues,
	merge,
	mergeWith,
	omit,
	omitBy,
	pick,
	pickBy,
	result,
	set,
	setWith,
	toPairs,
	toPairsIn,
	transform,
	unset,
	update,
	updateWith,
	values,
	valuesIn,
	methods,
	methodsIn,
	chain,
	tap,
	thru,
	camelCase,
	capitalize,
	deburr,
	endsWith,
	escape: escapeUtil,
	escapeRegExp,
	kebabCase,
	lowerCase,
	lowerFirst,
	pad,
	padEnd,
	padStart,
	parseInt: globalThis.parseInt,
	repeat,
	replace,
	snakeCase,
	split,
	startCase,
	startsWith,
	template,
	toLower,
	toUpper,
	trim,
	trimEnd,
	trimStart,
	truncate,
	unescape: unescapeUtil,
	upperCase,
	upperFirst,
	words,
};

void parityTypeCoverage;

const typeCaseArrayNumbers: number[] = map([1, 2, 3], (n: number) => n);
const typeCaseUsers = [
	{ id: "a", n: 1 },
	{ id: "b", n: 2 },
] as const;
const typeCaseGrouped: Record<string, readonly { id: "a" | "b"; n: 1 | 2 }[]> =
	groupBy(typeCaseUsers, "id");
const typeCaseFound: { id: "a" | "b"; n: 1 | 2 } | undefined = find(
	typeCaseUsers,
	["id", "a"],
);
const typeCaseFilteredByTuple: Array<{ id: "a" | "b"; n: 1 | 2 }> = filter(
	typeCaseUsers,
	["id", "b"],
);
const typeCaseUnionBy: unknown[] = unionBy([{ x: 1 }], [{ x: 2 }], "x");
const typeCaseXorWith: unknown[] = xorWith(
	[{ x: 1 }],
	[{ x: 1 }],
	(a: unknown, b: unknown) => (a as { x: number }).x === (b as { x: number }).x,
);
const typeCaseTemplate: string = template("hello <%= user %>")({
	user: "fred",
});
const typeCaseChain: number[] = chain([1, 2])
	.thru((list) => list.map((n: number) => n + 1))
	.value();
const typeCaseUpdateWith: Record<PropertyKey, unknown> = updateWith(
	{},
	"a.b",
	(value) => ((value as number | undefined) ?? 0) + 1,
	() => ({}),
);
const typeCaseToNumber: number = toNumber("3.2");
const typeCaseToString: string = toStringUtil(-0);

void typeCaseArrayNumbers;
void typeCaseGrouped;
void typeCaseFound;
void typeCaseFilteredByTuple;
void typeCaseUnionBy;
void typeCaseXorWith;
void typeCaseTemplate;
void typeCaseChain;
void typeCaseUpdateWith;
void typeCaseToNumber;
void typeCaseToString;
