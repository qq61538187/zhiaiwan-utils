/**
 * Purpose：Define authoritative method inventory and category/group metadata for the whole library.
 * Used in：build scripts, verify scripts, docs navigation/config, and export generation logic.
 * Why：Central metadata ensures all pipelines (runtime/types/docs/exports) stay aligned on exactly the same method set.
 */
export const GROUP_METHODS = {
	object: [
		"assign",
		"assignIn",
		"assignInWith",
		"assignWith",
		"at",
		"create",
		"defaults",
		"defaultsDeep",
		"entries",
		"entriesIn",
		"extend",
		"extendWith",
		"findKey",
		"findLastKey",
		"forIn",
		"forInRight",
		"forOwn",
		"forOwnRight",
		"functions",
		"functionsIn",
		"get",
		"has",
		"hasIn",
		"invert",
		"invertBy",
		"invoke",
		"keys",
		"keysIn",
		"mapKeys",
		"mapValues",
		"merge",
		"mergeWith",
		"omit",
		"omitBy",
		"pick",
		"pickBy",
		"result",
		"set",
		"setWith",
		"toPairs",
		"toPairsIn",
		"transform",
		"unset",
		"update",
		"updateWith",
		"values",
		"valuesIn",
		"methods",
		"methodsIn",
	],
	array: [
		"chunk",
		"compact",
		"concat",
		"difference",
		"differenceBy",
		"differenceWith",
		"drop",
		"dropRight",
		"dropRightWhile",
		"dropWhile",
		"fill",
		"findIndex",
		"findLastIndex",
		"first",
		"flatten",
		"flattenDeep",
		"flattenDepth",
		"fromPairs",
		"head",
		"indexOf",
		"initial",
		"intersection",
		"intersectionBy",
		"intersectionWith",
		"join",
		"last",
		"lastIndexOf",
		"nth",
		"pull",
		"pullAll",
		"pullAllBy",
		"pullAllWith",
		"pullAt",
		"remove",
		"reverse",
		"slice",
		"sortedIndex",
		"sortedIndexBy",
		"sortedIndexOf",
		"sortedLastIndex",
		"sortedLastIndexBy",
		"sortedLastIndexOf",
		"sortedUniq",
		"sortedUniqBy",
		"tail",
		"take",
		"takeRight",
		"takeRightWhile",
		"takeWhile",
		"union",
		"unionBy",
		"unionWith",
		"unique",
		"uniq",
		"uniqBy",
		"uniqWith",
		"unzip",
		"unzipWith",
		"without",
		"xor",
		"xorBy",
		"xorWith",
		"zip",
		"zipObject",
		"zipObjectDeep",
		"zipWith",
	],
	func: [
		"after",
		"ary",
		"before",
		"bind",
		"bindKey",
		"curry",
		"curryRight",
		"debounce",
		"defer",
		"delay",
		"flip",
		"memoize",
		"negate",
		"once",
		"overArgs",
		"partial",
		"partialRight",
		"rearg",
		"rest",
		"spread",
		"throttle",
		"unary",
		"wrap",
	],
	util: [
		"attempt",
		"bindAll",
		"cond",
		"conforms",
		"constant",
		"defaultTo",
		"flow",
		"flowRight",
		"identity",
		"iteratee",
		"matches",
		"matchesProperty",
		"method",
		"methodOf",
		"mixin",
		"noConflict",
		"noop",
		"nthArg",
		"over",
		"overEvery",
		"overSome",
		"property",
		"propertyOf",
		"range",
		"rangeRight",
		"runInContext",
		"stubArray",
		"stubFalse",
		"stubObject",
		"stubString",
		"stubTrue",
		"times",
		"toPath",
		"uniqueId",
	],
	collection: [
		"countBy",
		"every",
		"filter",
		"find",
		"findLast",
		"flatMap",
		"flatMapDeep",
		"flatMapDepth",
		"forEach",
		"forEachRight",
		"groupBy",
		"includes",
		"invokeMap",
		"keyBy",
		"map",
		"orderBy",
		"partition",
		"reduce",
		"reduceRight",
		"reject",
		"sample",
		"sampleSize",
		"shuffle",
		"size",
		"some",
		"sortBy",
		"each",
		"eachRight",
	],
	string: [
		"camelCase",
		"capitalize",
		"deburr",
		"endsWith",
		"escape",
		"escapeRegExp",
		"kebabCase",
		"lowerCase",
		"lowerFirst",
		"pad",
		"padEnd",
		"padStart",
		"parseInt",
		"repeat",
		"replace",
		"snakeCase",
		"split",
		"startCase",
		"startsWith",
		"template",
		"toLower",
		"toUpper",
		"trim",
		"trimEnd",
		"trimStart",
		"truncate",
		"unescape",
		"upperCase",
		"upperFirst",
		"words",
	],
	lang: [
		"castArray",
		"clone",
		"cloneDeep",
		"cloneDeepWith",
		"cloneWith",
		"conformsTo",
		"eq",
		"gt",
		"gte",
		"isArguments",
		"isArray",
		"isArrayBuffer",
		"isArrayLike",
		"isArrayLikeObject",
		"isBoolean",
		"isBuffer",
		"isDate",
		"isElement",
		"isEmpty",
		"isEqual",
		"isEqualWith",
		"isError",
		"isFinite",
		"isFunction",
		"isInteger",
		"isLength",
		"isMap",
		"isMatch",
		"isMatchWith",
		"isNaN",
		"isNative",
		"isNil",
		"isNull",
		"isNumber",
		"isObject",
		"isObjectLike",
		"isPlainObject",
		"isRegExp",
		"isSafeInteger",
		"isSet",
		"isString",
		"isSymbol",
		"isTypedArray",
		"isUndefined",
		"isWeakMap",
		"isWeakSet",
		"lt",
		"lte",
		"toArray",
		"toFinite",
		"toInteger",
		"toLength",
		"toNumber",
		"toPlainObject",
		"toSafeInteger",
		"toString",
	],
	math: [
		"add",
		"ceil",
		"divide",
		"floor",
		"max",
		"maxBy",
		"mean",
		"meanBy",
		"min",
		"minBy",
		"multiply",
		"round",
		"subtract",
		"sum",
		"sumBy",
	],
	number: ["clamp", "inRange", "random"],
	date: ["now"],
	seq: ["chain", "tap", "thru"],
};

export const GROUP_EXPORTS = Object.keys(GROUP_METHODS);
export const ROOT_METHODS = GROUP_EXPORTS.flatMap((groupName) => GROUP_METHODS[groupName]);

export const ALIAS_TO_CANONICAL = Object.freeze({
	each: "forEach",
	eachRight: "forEachRight",
	entries: "toPairs",
	entriesIn: "toPairsIn",
	extend: "assignIn",
	extendWith: "assignInWith",
	first: "head",
	methods: "functions",
	methodsIn: "functionsIn",
	unique: "uniq",
});

const METHOD_TO_GROUP = Object.freeze(
	Object.fromEntries(
		Object.entries(GROUP_METHODS).flatMap(([groupName, methods]) =>
			methods.map((methodName) => [methodName, groupName]),
		),
	),
);

const CANONICAL_TO_ALIASES = Object.freeze(
	Object.entries(ALIAS_TO_CANONICAL).reduce((accumulator, [aliasName, canonicalName]) => {
		if (!accumulator[canonicalName]) {
			accumulator[canonicalName] = [];
		}
		accumulator[canonicalName].push(aliasName);
		return accumulator;
	}, {}),
);

export const METHOD_META = Object.freeze(
	Object.fromEntries(
		ROOT_METHODS.map((methodName) => {
			const canonical = ALIAS_TO_CANONICAL[methodName] ?? methodName;
			return [
				methodName,
				{
					name: methodName,
					group: METHOD_TO_GROUP[methodName],
					canonical,
					aliases: CANONICAL_TO_ALIASES[methodName] ?? [],
					stability: "stable",
					since: "0.1.0",
				},
			];
		}),
	),
);

export const MATH_METHODS = GROUP_METHODS.math;
export const NUMBER_METHODS = GROUP_METHODS.number;
export const OBJECT_METHODS = GROUP_METHODS.object;
export const ARRAY_METHODS = GROUP_METHODS.array;
export const FUNCTION_METHODS = GROUP_METHODS.func;
export const UTIL_METHODS = GROUP_METHODS.util;
export const COLLECTION_METHODS = GROUP_METHODS.collection;
export const STRING_METHODS = GROUP_METHODS.string;
export const LANG_METHODS = GROUP_METHODS.lang;
export const DATE_METHODS = GROUP_METHODS.date;
export const SEQ_METHODS = GROUP_METHODS.seq;
