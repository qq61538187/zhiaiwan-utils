import { describe, expect, it } from "vitest";
import * as utils from "../src/index";

const METHODS_BY_GROUP = {
	array: [
		"chunk",
		"compact",
		"concat",
		"difference",
		"differenceBy",
		"differenceWith",
		"drop",
		"dropRight",
		"dropRightWhile",
		"dropWhile",
		"fill",
		"findIndex",
		"findLastIndex",
		"flatten",
		"flattenDeep",
		"flattenDepth",
		"fromPairs",
		"head",
		"indexOf",
		"initial",
		"intersection",
		"intersectionBy",
		"intersectionWith",
		"join",
		"last",
		"lastIndexOf",
		"nth",
		"pull",
		"pullAll",
		"pullAllBy",
		"pullAllWith",
		"pullAt",
		"remove",
		"reverse",
		"slice",
		"sortedIndex",
		"sortedIndexBy",
		"sortedIndexOf",
		"sortedLastIndex",
		"sortedLastIndexBy",
		"sortedLastIndexOf",
		"sortedUniq",
		"sortedUniqBy",
		"tail",
		"take",
		"takeRight",
		"takeRightWhile",
		"takeWhile",
		"union",
		"unionBy",
		"unionWith",
		"uniq",
		"uniqBy",
		"uniqWith",
		"unzip",
		"unzipWith",
		"without",
		"xor",
		"xorBy",
		"xorWith",
		"zip",
		"zipObject",
		"zipObjectDeep",
		"zipWith",
		"first",
	],
	collection: [
		"countBy",
		"every",
		"filter",
		"find",
		"findLast",
		"flatMap",
		"flatMapDeep",
		"flatMapDepth",
		"forEach",
		"forEachRight",
		"groupBy",
		"includes",
		"invokeMap",
		"keyBy",
		"map",
		"orderBy",
		"partition",
		"reduce",
		"reduceRight",
		"reject",
		"sample",
		"sampleSize",
		"shuffle",
		"size",
		"some",
		"sortBy",
		"each",
		"eachRight",
	],
	date: ["now"],
	func: [
		"after",
		"ary",
		"before",
		"bind",
		"bindKey",
		"curry",
		"curryRight",
		"debounce",
		"defer",
		"delay",
		"flip",
		"memoize",
		"negate",
		"once",
		"overArgs",
		"partial",
		"partialRight",
		"rearg",
		"rest",
		"spread",
		"throttle",
		"unary",
		"wrap",
	],
	lang: [
		"castArray",
		"clone",
		"cloneDeep",
		"cloneDeepWith",
		"cloneWith",
		"conformsTo",
		"eq",
		"gt",
		"gte",
		"isArguments",
		"isArray",
		"isArrayBuffer",
		"isArrayLike",
		"isArrayLikeObject",
		"isBoolean",
		"isBuffer",
		"isDate",
		"isElement",
		"isEmpty",
		"isEqual",
		"isEqualWith",
		"isError",
		"isFinite",
		"isFunction",
		"isInteger",
		"isLength",
		"isMap",
		"isMatch",
		"isMatchWith",
		"isNaN",
		"isNative",
		"isNil",
		"isNull",
		"isNumber",
		"isObject",
		"isObjectLike",
		"isPlainObject",
		"isRegExp",
		"isSafeInteger",
		"isSet",
		"isString",
		"isSymbol",
		"isTypedArray",
		"isUndefined",
		"isWeakMap",
		"isWeakSet",
		"lt",
		"lte",
		"toArray",
		"toFinite",
		"toInteger",
		"toLength",
		"toNumber",
		"toPlainObject",
		"toSafeInteger",
		"toString",
	],
	math: [
		"add",
		"ceil",
		"divide",
		"floor",
		"max",
		"maxBy",
		"mean",
		"meanBy",
		"min",
		"minBy",
		"multiply",
		"round",
		"subtract",
		"sum",
		"sumBy",
	],
	number: ["clamp", "inRange", "random"],
	object: [
		"assign",
		"assignIn",
		"assignInWith",
		"assignWith",
		"at",
		"create",
		"defaults",
		"defaultsDeep",
		"entries",
		"entriesIn",
		"extend",
		"extendWith",
		"findKey",
		"findLastKey",
		"forIn",
		"forInRight",
		"forOwn",
		"forOwnRight",
		"functions",
		"functionsIn",
		"get",
		"has",
		"hasIn",
		"invert",
		"invertBy",
		"invoke",
		"keys",
		"keysIn",
		"mapKeys",
		"mapValues",
		"merge",
		"mergeWith",
		"omit",
		"omitBy",
		"pick",
		"pickBy",
		"result",
		"set",
		"setWith",
		"toPairs",
		"toPairsIn",
		"transform",
		"unset",
		"update",
		"updateWith",
		"values",
		"valuesIn",
		"methods",
		"methodsIn",
	],
	seq: ["chain", "tap", "thru"],
	string: [
		"camelCase",
		"capitalize",
		"deburr",
		"endsWith",
		"escape",
		"escapeRegExp",
		"kebabCase",
		"lowerCase",
		"lowerFirst",
		"pad",
		"padEnd",
		"padStart",
		"parseInt",
		"repeat",
		"replace",
		"snakeCase",
		"split",
		"startCase",
		"startsWith",
		"template",
		"toLower",
		"toUpper",
		"trim",
		"trimEnd",
		"trimStart",
		"truncate",
		"unescape",
		"upperCase",
		"upperFirst",
		"words",
	],
} as const;

describe("method 10-category method presence", () => {
	it("exposes all baseline methods and aliases from root entry", () => {
		for (const [group, methods] of Object.entries(METHODS_BY_GROUP)) {
			for (const method of methods) {
				expect(
					method in utils,
					`missing ${group}/${method} in src/index.ts export`,
				).toBe(true);
				expect(typeof (utils as Record<string, unknown>)[method]).toBe(
					"function",
				);
			}
		}
	});
});
